/**
 * Template Task Service
 *
 * @role 템플릿 → 오늘 할 일 생성 통합 파이프라인
 * @responsibilities
 *   - 템플릿에서 작업 생성 (단일 파이프라인)
 *   - 자동생성 상태 관리
 *   - 실행 로그 기록
 *   - 시간 추정 학습 데이터 수집
 *
 * @dependencies
 *   - templateRepository: 템플릿 CRUD
 *   - dailyDataStore: 오늘 할 일 추가
 *   - systemRepository: 상태 저장
 */

import type { Template, Task } from '@/shared/types/domain';
import { createTaskFromTemplate, updateTemplate } from '@/data/repositories/templateRepository';
import { useDailyDataStore } from '@/shared/stores/dailyDataStore';
import {
  getSystemState,
  setSystemState,
  SYSTEM_KEYS,
} from '@/data/repositories/systemRepository';
import {
  TEMPLATE_DEFAULTS,
  type TemplateAutoGenerateState,
  type TemplateExecutionLog,
  type TemplateExecutionLogEntry,
  type TemplateUiPrefs,
} from '@/shared/constants/defaults';
import { getLocalDate } from '@/shared/lib/utils';

// ============================================================================
// UI Preferences 관리
// ============================================================================

/**
 * 템플릿 UI 환경설정 로드
 */
export async function loadTemplateUiPrefs(): Promise<TemplateUiPrefs> {
  const stored = await getSystemState<TemplateUiPrefs>(SYSTEM_KEYS.TEMPLATE_UI_PREFS);
  return {
    sortBy: stored?.sortBy ?? TEMPLATE_DEFAULTS.defaultSortBy,
    sortOrder: stored?.sortOrder ?? TEMPLATE_DEFAULTS.defaultSortOrder,
    lastCategory: stored?.lastCategory,
    showFavoritesOnly: stored?.showFavoritesOnly ?? false,
  };
}

/**
 * 템플릿 UI 환경설정 저장
 */
export async function saveTemplateUiPrefs(prefs: Partial<TemplateUiPrefs>): Promise<void> {
  const current = await loadTemplateUiPrefs();
  await setSystemState(SYSTEM_KEYS.TEMPLATE_UI_PREFS, { ...current, ...prefs });
}

// ============================================================================
// 자동생성 상태 관리
// ============================================================================

/**
 * 자동생성 상태 로드
 */
export async function loadAutoGenerateState(): Promise<TemplateAutoGenerateState> {
  const stored = await getSystemState<TemplateAutoGenerateState>(
    SYSTEM_KEYS.TEMPLATE_AUTO_GENERATE_STATE
  );
  return {
    lastRunDate: stored?.lastRunDate ?? null,
    lastRunAt: stored?.lastRunAt ?? null,
    lastGeneratedCount: stored?.lastGeneratedCount ?? 0,
    lastRunSuccess: stored?.lastRunSuccess ?? false,
  };
}

/**
 * 자동생성 상태 저장
 */
export async function saveAutoGenerateState(state: TemplateAutoGenerateState): Promise<void> {
  await setSystemState(SYSTEM_KEYS.TEMPLATE_AUTO_GENERATE_STATE, state);
}

/**
 * 오늘 자동생성이 이미 실행되었는지 확인
 */
export async function hasAutoGeneratedToday(): Promise<boolean> {
  const state = await loadAutoGenerateState();
  const today = getLocalDate();
  return state.lastRunDate === today && state.lastRunSuccess;
}

/**
 * 자동생성 실행 완료 기록
 */
export async function markAutoGenerateComplete(generatedCount: number): Promise<void> {
  const now = new Date().toISOString();
  await saveAutoGenerateState({
    lastRunDate: getLocalDate(),
    lastRunAt: now,
    lastGeneratedCount: generatedCount,
    lastRunSuccess: true,
  });
}

// ============================================================================
// 실행 로그 관리
// ============================================================================

/**
 * 실행 로그 로드
 */
export async function loadExecutionLog(): Promise<TemplateExecutionLog> {
  const stored = await getSystemState<TemplateExecutionLog>(SYSTEM_KEYS.TEMPLATE_EXECUTION_LOG);
  return {
    entries: stored?.entries ?? [],
  };
}

/**
 * 실행 로그에 항목 추가 (최대 50개 유지)
 */
export async function addExecutionLogEntry(entry: TemplateExecutionLogEntry): Promise<void> {
  const log = await loadExecutionLog();
  const newEntries = [entry, ...log.entries].slice(0, TEMPLATE_DEFAULTS.executionLogMaxItems);
  await setSystemState(SYSTEM_KEYS.TEMPLATE_EXECUTION_LOG, { entries: newEntries });
}

/**
 * 실제 소요시간 업데이트 (작업 완료 시 호출)
 */
export async function updateExecutionLogActualDuration(
  templateId: string,
  actualDuration: number
): Promise<void> {
  const log = await loadExecutionLog();
  const updatedEntries = log.entries.map((entry) => {
    // 가장 최근의 해당 템플릿 항목 중 actualDuration이 없는 것 업데이트
    if (entry.templateId === templateId && entry.actualDuration === undefined) {
      return { ...entry, actualDuration };
    }
    return entry;
  });
  await setSystemState(SYSTEM_KEYS.TEMPLATE_EXECUTION_LOG, { entries: updatedEntries });
}

// ============================================================================
// 단일 파이프라인: 템플릿 → 오늘 할 일 생성
// ============================================================================

export interface CreateTaskFromTemplateResult {
  success: boolean;
  task?: Task;
  error?: string;
}

/**
 * 템플릿에서 오늘 할 일 생성 (단일 파이프라인)
 *
 * @param template - 템플릿 객체
 * @param source - 생성 방식 (auto: 자동생성, manual: 수동)
 * @returns 생성 결과
 */
export async function createTodayTaskFromTemplate(
  template: Template,
  source: 'auto' | 'manual' = 'manual'
): Promise<CreateTaskFromTemplateResult> {
  try {
    // 1. Task 생성
    const task = createTaskFromTemplate(template);

    // 2. DailyData에 추가
    const dailyDataStore = useDailyDataStore.getState();
    await dailyDataStore.addTask(task);

    // 3. 실행 로그 기록
    const logEntry: TemplateExecutionLogEntry = {
      executedAt: new Date().toISOString(),
      templateId: template.id,
      templateName: template.name,
      estimatedDuration: template.baseDuration,
      source,
    };
    await addExecutionLogEntry(logEntry);

    // 4. 수동 생성 시 템플릿의 lastGeneratedDate 업데이트
    if (source === 'manual') {
      await updateTemplate(template.id, {
        lastGeneratedDate: getLocalDate(),
      });
    }

    return { success: true, task };
  } catch (error) {
    console.error('Failed to create task from template:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : '작업 생성에 실패했습니다.',
    };
  }
}

/**
 * 여러 템플릿에서 작업 일괄 생성
 */
export async function createTasksFromTemplates(
  templates: Template[],
  source: 'auto' | 'manual' = 'manual'
): Promise<CreateTaskFromTemplateResult[]> {
  const results: CreateTaskFromTemplateResult[] = [];
  for (const template of templates) {
    const result = await createTodayTaskFromTemplate(template, source);
    results.push(result);
  }
  return results;
}

// ============================================================================
// 시간 추정 학습 데이터
// ============================================================================

export interface TimeEstimationFeedback {
  templateId: string;
  estimatedDuration: number;
  actualDuration: number;
  ratio: number; // actualDuration / estimatedDuration
}

/**
 * 템플릿별 시간 추정 피드백 계산
 */
export async function getTimeEstimationFeedback(
  templateId: string
): Promise<TimeEstimationFeedback | null> {
  const log = await loadExecutionLog();
  const entries = log.entries.filter(
    (e) => e.templateId === templateId && e.actualDuration !== undefined
  );

  if (entries.length === 0) return null;

  const totalEstimated = entries.reduce((sum, e) => sum + e.estimatedDuration, 0);
  const totalActual = entries.reduce((sum, e) => sum + (e.actualDuration ?? 0), 0);

  return {
    templateId,
    estimatedDuration: totalEstimated / entries.length,
    actualDuration: totalActual / entries.length,
    ratio: totalActual / totalEstimated,
  };
}

/**
 * 모든 템플릿의 시간 추정 피드백 조회
 */
export async function getAllTimeEstimationFeedback(): Promise<Map<string, TimeEstimationFeedback>> {
  const log = await loadExecutionLog();
  const feedbackMap = new Map<string, TimeEstimationFeedback>();

  // 템플릿별로 그룹화
  const templateGroups = new Map<string, TemplateExecutionLogEntry[]>();
  for (const entry of log.entries) {
    if (entry.actualDuration === undefined) continue;
    const existing = templateGroups.get(entry.templateId) ?? [];
    existing.push(entry);
    templateGroups.set(entry.templateId, existing);
  }

  // 각 템플릿에 대해 피드백 계산
  for (const [templateId, entries] of templateGroups) {
    const totalEstimated = entries.reduce((sum, e) => sum + e.estimatedDuration, 0);
    const totalActual = entries.reduce((sum, e) => sum + (e.actualDuration ?? 0), 0);
    feedbackMap.set(templateId, {
      templateId,
      estimatedDuration: totalEstimated / entries.length,
      actualDuration: totalActual / entries.length,
      ratio: totalActual / totalEstimated,
    });
  }

  return feedbackMap;
}

// ============================================================================
// Feature Flag 관리
// ============================================================================

/**
 * UX v1 기능 활성화 여부 확인
 */
export async function isUxV1Enabled(): Promise<boolean> {
  const stored = await getSystemState<boolean>(SYSTEM_KEYS.TEMPLATE_UX_V1_ENABLED);
  return stored ?? TEMPLATE_DEFAULTS.uxV1Enabled;
}

/**
 * UX v1 기능 활성화/비활성화
 */
export async function setUxV1Enabled(enabled: boolean): Promise<void> {
  await setSystemState(SYSTEM_KEYS.TEMPLATE_UX_V1_ENABLED, enabled);
}
