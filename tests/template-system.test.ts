/**
 * Template System Tests
 *
 * Tests for:
 * 1. Form validation (Zod schema)
 * 2. Auto-generate once-per-day logic
 * 3. UI preferences persistence
 */

import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import 'fake-indexeddb/auto';

// 실제 스키마 import (동적 import 필요 없음)
import {
  templateBasicSchema,
  validateBasicStep,
} from '../src/shared/schemas/templateSchemas';

// ============================================================================
// Test 1: Form Validation (Zod Schema)
// ============================================================================
describe('Template Form Validation (Zod Schema)', () => {
  it('should pass validation for valid basic form data', () => {
    const validData = {
      text: '운동하기',
      baseDuration: 30,
      resistance: 'medium' as const,
      timeBlock: 'morning' as const,
      memo: '',
      category: '',
      imageUrl: '',
      isFavorite: false,
    };

    const result = templateBasicSchema.safeParse(validData);
    
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.text).toBe('운동하기');
      expect(result.data.baseDuration).toBe(30);
    }
  });

  it('should fail validation when text is empty', () => {
    const invalidData = {
      text: '',
      baseDuration: 30,
      resistance: 'low' as const,
      timeBlock: null,
    };

    const result = templateBasicSchema.safeParse(invalidData);
    
    expect(result.success).toBe(false);
    if (!result.success) {
      // Zod 에러 구조에서 이슈 찾기
      const textError = result.error.issues.find(e => e.path.includes('text'));
      expect(textError).toBeDefined();
      expect(textError?.message).toContain('입력');
    }
  });

  it('should fail validation when baseDuration is less than 1', () => {
    const invalidData = {
      text: '유효한 텍스트',
      baseDuration: 0,
      resistance: 'low' as const,
      timeBlock: null,
    };

    const result = templateBasicSchema.safeParse(invalidData);
    
    expect(result.success).toBe(false);
    if (!result.success) {
      const durationError = result.error.issues.find(e => 
        e.path.includes('baseDuration')
      );
      expect(durationError).toBeDefined();
    }
  });

  it('should fail validation when resistance is invalid enum value', () => {
    const invalidData = {
      text: '유효한 텍스트',
      baseDuration: 30,
      resistance: 'invalid' as never,
      timeBlock: null,
    };

    const result = templateBasicSchema.safeParse(invalidData);
    
    expect(result.success).toBe(false);
  });

  it('should apply default values for optional fields using validateBasicStep', () => {
    const minimalData = {
      text: '최소 데이터',
      baseDuration: 15,
      resistance: 'low' as const,
      timeBlock: null,
    };

    const result = validateBasicStep(minimalData);
    
    expect(result.success).toBe(true);
    if (result.success && result.data) {
      expect(result.data.memo).toBe('');
      expect(result.data.isFavorite).toBe(false);
    }
  });

  it('should return errors in record format using validateBasicStep', () => {
    const invalidData = {
      text: '',
      baseDuration: -10,
      resistance: 'low' as const,
      timeBlock: null,
    };

    const result = validateBasicStep(invalidData);
    
    expect(result.success).toBe(false);
    expect(result.errors).toBeDefined();
    expect(result.errors?.text).toBeDefined();
    expect(result.errors?.baseDuration).toBeDefined();
  });
});

// ============================================================================
// Test 2: Auto-generate Once-per-Day Logic
// ============================================================================
describe('Auto-generate Once-per-Day Logic', () => {
  // 모듈 mock을 위한 spy 저장
  let mockGetSystemState: ReturnType<typeof vi.fn>;
  let mockSetSystemState: ReturnType<typeof vi.fn>;

  beforeEach(async () => {
    // Reset mocks
    vi.resetModules();
    vi.clearAllMocks();
    
    // Mock systemRepository
    mockGetSystemState = vi.fn();
    mockSetSystemState = vi.fn().mockResolvedValue(undefined);
    
    vi.doMock('../src/data/repositories/systemRepository', () => ({
      getSystemState: mockGetSystemState,
      setSystemState: mockSetSystemState,
      SYSTEM_KEYS: {
        TEMPLATE_UI_PREFS: 'template:uiPrefs',
        TEMPLATE_AUTO_GENERATE_STATE: 'template:autoGenerateState',
        TEMPLATE_EXECUTION_LOG: 'template:executionLog',
        TEMPLATE_DURATION_FEEDBACK: 'template:durationFeedback',
        TEMPLATE_UX_V1_ENABLED: 'template:uxV1Enabled',
      },
    }));
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should return false when no previous auto-generate state exists', async () => {
    mockGetSystemState.mockResolvedValue(null);

    const { hasAutoGeneratedToday } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    const result = await hasAutoGeneratedToday();
    
    expect(result).toBe(false);
  });

  it('should return false when last auto-generate was on a different day', async () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split('T')[0];

    mockGetSystemState.mockResolvedValue({
      lastRunDate: yesterdayStr,
      lastGeneratedCount: 3,
      lastRunSuccess: true,
    });

    const { hasAutoGeneratedToday } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    const result = await hasAutoGeneratedToday();
    
    expect(result).toBe(false);
  });

  it('should return true when auto-generate already ran today', async () => {
    const today = new Date().toISOString().split('T')[0];

    mockGetSystemState.mockResolvedValue({
      lastRunDate: today,
      lastGeneratedCount: 5,
      lastRunSuccess: true,
    });

    const { hasAutoGeneratedToday } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    const result = await hasAutoGeneratedToday();
    
    expect(result).toBe(true);
  });

  it('should mark auto-generate as complete for today', async () => {
    mockGetSystemState.mockResolvedValue(null);

    const { markAutoGenerateComplete } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    await markAutoGenerateComplete(3);
    
    expect(mockSetSystemState).toHaveBeenCalledWith(
      'template:autoGenerateState',
      expect.objectContaining({
        lastRunDate: expect.any(String),
        lastGeneratedCount: 3,
        lastRunSuccess: true,
      })
    );
  });
});

// ============================================================================
// Test 2.5: Midnight Boundary - Date-based Guard (로컬 날짜 기준 자정 경계 테스트)
// ============================================================================
describe('Auto-generate Midnight Boundary', () => {
  let mockGetSystemState: ReturnType<typeof vi.fn>;
  let mockSetSystemState: ReturnType<typeof vi.fn>;

  beforeEach(async () => {
    vi.resetModules();
    vi.clearAllMocks();
    
    mockGetSystemState = vi.fn();
    mockSetSystemState = vi.fn().mockResolvedValue(undefined);
    
    vi.doMock('../src/data/repositories/systemRepository', () => ({
      getSystemState: mockGetSystemState,
      setSystemState: mockSetSystemState,
      SYSTEM_KEYS: {
        TEMPLATE_UI_PREFS: 'template:uiPrefs',
        TEMPLATE_AUTO_GENERATE_STATE: 'template:autoGenerateState',
        TEMPLATE_EXECUTION_LOG: 'template:executionLog',
        TEMPLATE_DURATION_FEEDBACK: 'template:durationFeedback',
        TEMPLATE_UX_V1_ENABLED: 'template:uxV1Enabled',
      },
    }));
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should allow auto-generate after midnight (next day)', async () => {
    // Scenario: 23:59 KST에 실행 후 → 00:01 KST에 재실행
    // 로컬 날짜가 변경되었으므로 다음 날에는 다시 실행 허용
    
    // 어제 날짜로 마지막 실행 상태 설정
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split('T')[0];

    mockGetSystemState.mockResolvedValue({
      lastRunDate: yesterdayStr,
      lastRunAt: new Date(yesterday.getTime() + 23 * 60 * 60 * 1000 + 59 * 60 * 1000).toISOString(), // 23:59
      lastGeneratedCount: 2,
      lastRunSuccess: true,
    });

    const { hasAutoGeneratedToday } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    // 오늘(다음 날) 00:01에 실행 → 아직 실행 안 됨으로 판정
    const result = await hasAutoGeneratedToday();
    expect(result).toBe(false); // 다음 날이므로 다시 실행 허용
  });

  it('should block auto-generate on same local date (even if hours differ)', async () => {
    // Scenario: 오늘 06:00에 실행 → 오늘 18:00에 재실행 시도
    // 같은 로컬 날짜이므로 차단
    
    const today = new Date().toISOString().split('T')[0];

    mockGetSystemState.mockResolvedValue({
      lastRunDate: today,
      lastRunAt: new Date().toISOString(),
      lastGeneratedCount: 3,
      lastRunSuccess: true,
    });

    const { hasAutoGeneratedToday } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    const result = await hasAutoGeneratedToday();
    expect(result).toBe(true); // 같은 날짜이므로 차단
  });

  it('should use local date (YYYY-MM-DD) for comparison, not timestamp', async () => {
    // getLocalDate()가 로컬 시간대 기준 YYYY-MM-DD를 반환하는지 확인
    const { getLocalDate } = await import('../src/shared/lib/utils');

    // 현재 시스템 시간대 기준으로 날짜 생성
    const now = new Date();
    const localDateStr = getLocalDate(now);
    
    // 형식 검증: YYYY-MM-DD
    expect(localDateStr).toMatch(/^\d{4}-\d{2}-\d{2}$/);
    
    // 날짜 파싱 검증
    const [year, month, day] = localDateStr.split('-').map(Number);
    expect(year).toBe(now.getFullYear());
    expect(month).toBe(now.getMonth() + 1);
    expect(day).toBe(now.getDate());
  });

  it('should correctly detect date change at midnight boundary', async () => {
    // 자정 직전 (23:59:59) vs 자정 직후 (00:00:01)에 getLocalDate가 다른 값을 반환하는지 확인
    const { getLocalDate } = await import('../src/shared/lib/utils');

    // 임의의 날짜 생성: 2025-12-23 23:59:59
    const beforeMidnight = new Date(2025, 11, 23, 23, 59, 59);
    const afterMidnight = new Date(2025, 11, 24, 0, 0, 1);

    const dateBefore = getLocalDate(beforeMidnight);
    const dateAfter = getLocalDate(afterMidnight);

    expect(dateBefore).toBe('2025-12-23');
    expect(dateAfter).toBe('2025-12-24');
    expect(dateBefore).not.toBe(dateAfter);
  });
});

// ============================================================================
// Test 3: UI Preferences Persistence
// ============================================================================
describe('Template UI Preferences Persistence', () => {
  let mockGetSystemState: ReturnType<typeof vi.fn>;
  let mockSetSystemState: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.resetModules();
    vi.clearAllMocks();
    
    mockGetSystemState = vi.fn();
    mockSetSystemState = vi.fn().mockResolvedValue(undefined);
    
    vi.doMock('../src/data/repositories/systemRepository', () => ({
      getSystemState: mockGetSystemState,
      setSystemState: mockSetSystemState,
      SYSTEM_KEYS: {
        TEMPLATE_UI_PREFS: 'template:uiPrefs',
        TEMPLATE_AUTO_GENERATE_STATE: 'template:autoGenerateState',
        TEMPLATE_EXECUTION_LOG: 'template:executionLog',
        TEMPLATE_DURATION_FEEDBACK: 'template:durationFeedback',
        TEMPLATE_UX_V1_ENABLED: 'template:uxV1Enabled',
      },
    }));
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should load default preferences when none exist', async () => {
    mockGetSystemState.mockResolvedValue(null);

    const { loadTemplateUiPrefs } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    const prefs = await loadTemplateUiPrefs();
    
    // Should return defaults from TEMPLATE_DEFAULTS
    expect(prefs).toEqual(
      expect.objectContaining({
        sortBy: expect.any(String),
        sortOrder: expect.any(String),
        showFavoritesOnly: false,
      })
    );
  });

  it('should load saved preferences when they exist', async () => {
    const savedPrefs = {
      sortBy: 'name',
      sortOrder: 'desc',
      lastCategory: 'work',
      showFavoritesOnly: true,
    };

    mockGetSystemState.mockResolvedValue(savedPrefs);

    const { loadTemplateUiPrefs } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    const prefs = await loadTemplateUiPrefs();
    
    expect(prefs.sortBy).toBe('name');
    expect(prefs.sortOrder).toBe('desc');
    expect(prefs.lastCategory).toBe('work');
    expect(prefs.showFavoritesOnly).toBe(true);
  });

  it('should save UI preferences correctly', async () => {
    mockGetSystemState.mockResolvedValue(null);

    const { saveTemplateUiPrefs } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    await saveTemplateUiPrefs({
      sortBy: 'baseDuration',
      sortOrder: 'asc',
    });
    
    expect(mockSetSystemState).toHaveBeenCalledWith(
      'template:uiPrefs',
      expect.objectContaining({
        sortBy: 'baseDuration',
        sortOrder: 'asc',
      })
    );
  });

  it('should merge partial preferences with existing ones', async () => {
    const existingPrefs = {
      sortBy: 'name',
      sortOrder: 'asc',
      showFavoritesOnly: false,
    };

    mockGetSystemState.mockResolvedValue(existingPrefs);

    const { saveTemplateUiPrefs } = await import(
      '../src/shared/services/template/templateTaskService'
    );

    // Only update sortOrder
    await saveTemplateUiPrefs({ sortOrder: 'desc' });
    
    expect(mockSetSystemState).toHaveBeenCalledWith(
      'template:uiPrefs',
      expect.objectContaining({
        sortBy: 'name', // preserved
        sortOrder: 'desc', // updated
        showFavoritesOnly: false, // preserved
      })
    );
  });
});
